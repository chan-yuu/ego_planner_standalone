#!/bin/bash

# EGO Planner 系统启动指南

echo "=========================================="
echo "  EGO Planner 系统正确启动顺序"
echo "=========================================="
echo ""

echo "修复说明:"
echo "  问题: ros_bridge 启动时读取到共享内存中的旧数据"
echo "  解决: 在 initAsProducer() 中清空 BsplineData 和 PlannerStateData"
echo ""

echo "启动顺序（必须按顺序执行）:"
echo ""
echo "终端1: 启动仿真环境"
echo "  $ cd ~/Documents/ego-planner/2.0/12.4-ego-planner/ego-planner"
echo "  $ source devel/setup.bash"
echo "  $ roslaunch ego_planner_bridge sim_only.launch"
echo ""
echo "等待仿真环境完全启动..."
echo ""
echo "终端2: 启动 planner_standalone"
echo "  $ cd ~/Documents/ego-planner/2.0/12.4-ego-planner/planner_standalone/build"
echo "  $ ./ego_planner_standalone"
echo ""
echo "等待看到 '共享内存初始化成功' 和 '规划器创建成功'"
echo ""
echo "终端3: 启动 ros_bridge"
echo "  $ cd ~/Documents/ego-planner/2.0/12.4-ego-planner/ego-planner"
echo "  $ source devel/setup.bash"
echo "  $ roslaunch ego_planner_bridge run_bridge.launch"
echo ""
echo "现在应该看到:"
echo "  - ros_bridge 连接到共享内存成功"
echo "  - 没有 'New bspline trajectory received' (因为还没规划)"
echo "  - 没有 'Planner state: ERROR'"
echo ""
echo "终端4: 在 RViz 中点击目标点触发规划"
echo "  使用 '2D Nav Goal' 工具在 RViz 中点击一个目标位置"
echo ""
echo "预期输出:"
echo "  standalone: '收到新目标点' -> '生成新轨迹' -> '全局规划成功'"
echo "  ros_bridge: 'New bspline trajectory received: N control points'"
echo "  RViz: 显示规划的轨迹路径"
echo ""

echo "=========================================="
echo "  清理共享内存（如果需要）"
echo "=========================================="
echo ""
echo "如果遇到共享内存问题，可以手动清理:"
echo "  $ ipcs -m | grep $(whoami)"
echo "  $ ipcrm -m <shared_memory_id>"
echo ""
echo "或者使用脚本自动清理:"
echo "  $ ipcs -m | grep $(whoami) | awk '{print \$2}' | xargs -I {} ipcrm -m {}"
echo ""

echo "=========================================="
echo "  故障排查"
echo "=========================================="
echo ""
echo "问题1: traj_server 崩溃"
echo "  原因: B样条数据格式错误（knots数量不匹配）"
echo "  解决: 已修复 - 直接从 bspline 对象获取 knots"
echo ""
echo "问题2: Eigen 索引越界"
echo "  原因: 控制点矩阵访问方式错误"
echo "  解决: 已修复 - 使用 cols() 而不是 rows()"
echo ""
echo "问题3: 启动时就有旧数据"
echo "  原因: 共享内存中的旧数据未清理"
echo "  解决: 已修复 - initAsProducer() 时清空数据"
echo ""
